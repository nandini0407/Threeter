<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Threeter</title>
		<style>
			body { margin: 0 auto; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="../vendor/three.js"></script>
    <script src="../vendor/cannon.js"></script>
    <script src="../vendor/threex.cannonworld.js"></script>
    <script src="../vendor/threex.cannonbody.js"></script>
    <script src="../vendor/threex.keyboardstate.js"></script>
    <script src="game.js"></script>
    <script>
      // Init keyboardstate
      var keyboard	= new THREEx.KeyboardState(document.body);
      keyboard.domElement.setAttribute("tabIndex", "0");
      keyboard.domElement.focus();

      // Basic scene, camera and renderer
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.01, 1000);
      camera.position.x	= 0;
    	camera.position.y	= 6;
    	camera.position.z	= 5;
    	camera.lookAt( scene.position );
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );

      // Build physics world
      var physicsWorld = new THREEx.CannonWorld();
      physicsWorld.start();

      // Add Lighting
      let light = new THREE.Object3D();
      scene.add(light);
      buildLight(light);
      // No physics for lighting

      const tileW = 0.2; // Don't know why we need this

			var pMaterialBall	= new CANNON.Material('pMaterialBall');
			var pMaterialFloor	= new CANNON.Material('pMaterialFloor');
			var pMaterialWall	= new CANNON.Material('pMaterialBall');
			physicsWorld.world.addContactMaterial(new CANNON.ContactMaterial(
				pMaterialBall,
				pMaterialFloor,
				0.1, // Friction
				0.2 // Bounciness
			));
			physicsWorld.world.addContactMaterial(new CANNON.ContactMaterial(
				pMaterialBall,
				pMaterialWall,
				0.1,	// friction coefficient
				0.01	// restitution
			));

      // Table
      let table	= new THREE.Object3D();
      // Add floor to table
      let floor_mesh = buildFloor(-35*tileW, -20*tileW, 35*tileW, 20*tileW);
      table.add(floor_mesh);
      scene.add(table);
      // Apply phyics to floor
      let floor_body	= new THREEx.CannonBody({
  			mesh: floor_mesh,
  			mass: 0, // In kgs, floor needs to be static so zero mass
  			material: pMaterialFloor
  		}).addTo(physicsWorld);

      // Add ball
      let ball_mesh = addBall(1*tileW);
      scene.add(ball_mesh);
      var ball_body	= new THREEx.CannonBody({
    		mesh: ball_mesh,
        mass: 20,
    		material: pMaterialBall
    	}).addTo(physicsWorld);
      ball_body.body.position.set(-15*tileW, 20*tileW, 0*tileW);
			ball_body.body.linearDamping = 0.8;
			ball_body.body.angularDamping	= 0.9;

			//Add walls
			//left boundary wall
			let wall_mesh_left = addWall(-32*tileW - tileW/2,-18*tileW - tileW/2,-32*tileW + tileW/2, 18*tileW + tileW/2);
			scene.add(wall_mesh_left);
			var wall_body_left	= new THREEx.CannonBody({
				mesh	: wall_mesh_left,
				mass	: 0,
				material: pMaterialWall
			}).addTo(physicsWorld);
			// right boundary wall
			let wall_mesh_right = addWall(32*tileW - tileW/2,-18*tileW - tileW/2,32*tileW + tileW/2, 18*tileW + tileW/2);
			scene.add(wall_mesh_right);
			var wall_body_right	= new THREEx.CannonBody({
				mesh	: wall_mesh_right,
				mass	: 0,
				material: pMaterialWall
			}).addTo(physicsWorld);

			// bottom boundary wall
			let wall_mesh_bottom = addWall(-32*tileW - tileW/2,-19*tileW - tileW/2,32*tileW + tileW/2, -19*tileW + tileW/2);
			scene.add(wall_mesh_bottom);
			var wall_body3	= new THREEx.CannonBody({
				mesh	: wall_mesh_bottom,
				mass	: 0,
				material: pMaterialWall
			}).addTo(physicsWorld);

			// top boundary wall
			let wall_mesh_top = addWall(-32*tileW - tileW/2, 19*tileW - tileW/2,32*tileW + tileW/2, 19*tileW + tileW/2);
			scene.add(wall_mesh_top);
			var wall_body4	= new THREEx.CannonBody({
				mesh	: wall_mesh_top,
				mass	: 0,
				material: pMaterialWall
			}).addTo(physicsWorld);

			// 3 middle blocking walls
			let wall_mesh1 = addWall(20*tileW - tileW/2,-8*tileW - tileW/2,20*tileW + tileW/2, 18*tileW + tileW/2);
			scene.add(wall_mesh1);
			var wall_body1	= new THREEx.CannonBody({
				mesh	: wall_mesh1,
				mass	: 0,
				material: pMaterialWall
			}).addTo(physicsWorld);
			let wall_mesh2 = addWall(4*tileW - tileW/2,-18*tileW - tileW/2,4*tileW + tileW/2, 8*tileW + tileW/2);
			scene.add(wall_mesh2);
			var wall_body2	= new THREEx.CannonBody({
				mesh	: wall_mesh2,
				mass	: 0,
				material: pMaterialWall
			}).addTo(physicsWorld);
			let wall_mesh3 = addWall(-12*tileW - tileW/2,-8*tileW - tileW/2,-12*tileW + tileW/2, 18*tileW + tileW/2);
			scene.add(wall_mesh3);
			var wall_body3	= new THREEx.CannonBody({
				mesh	: wall_mesh3,
				mass	: 0,
				material: pMaterialWall
			}).addTo(physicsWorld);

      var lastTimeMsec = null;
      let animate = function (nowMsec) {
				requestAnimationFrame(animate);
        lastTimeMsec	= lastTimeMsec || (nowMsec-1000/60);
        var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec);
        lastTimeMsec	= nowMsec;
        updateBallPosition(keyboard, ball_body, deltaMsec);
        ball_body.update(deltaMsec/1000, nowMsec/1000);
        renderer.render(scene, camera);
      }
      requestAnimationFrame(animate);
    </script>
  </body>
</html>
