<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Threeter</title>
    <style media="screen">
      canvas { width: 100%; height: 100% }
      body {
				margin: 0 auto;
				font-family: 'Ubuntu', sans-serif;
			}
			header { text-align: center; }
			ul { list-style: none }
    </style>
		<link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
    <script src='./vendor/three.js'></script>
    <script src='./lib/game.js'></script>
    <script src="./vendor/cannon.js"></script>
    <script src="./vendor/threex.cannonbody.js"></script>
    <script src="./vendor/threex.cannonworld.js"></script>
    <script src="./vendor/threex.keyboardstate.js"></script>
  </head>
  <body>
		<header>
			<h1>Threeter</h1>
			<ul>
				<li>Use arrow keys to move ball towards the green home ball</li>
				<li>Avoid contact with obstacles</li>
			</ul>
			<a href="https://github.com/nandini0407/Threeter/tree/master">Github</a>
			<a href="www.linkedin.com/in/nandini-adhyapaka">LinkedIn</a>
		</header>
    <script type="text/javascript">

      var keyboard = new THREEx.KeyboardState(document.body);
      keyboard.domElement.setAttribute("tabIndex", "0");
	    keyboard.domElement.focus();

      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.x	= 0;
    	camera.position.y	= 6;
    	camera.position.z	= 5;
    	camera.lookAt( scene.position );
      var renderer = new THREE.WebGLRenderer();

			var light = new THREE.AmbientLight( 0xffffff );
			scene.add(light);

      var pWorld = new THREEx.CannonWorld();
      pWorld.start();

			var pMaterialFloor = new CANNON.Material('pMaterialFloor');
      var pMaterialBall = new CANNON.Material('pMaterialBall');
      var pMaterialWall = new CANNON.Material('pMaterialWall');
			var pMaterialObstacle = new CANNON.Material('pMaterialObstacle');

			pWorld.world.addContactMaterial(new CANNON.ContactMaterial(
        pMaterialBall, pMaterialFloor, 0.2, 0.1
      ));

      pWorld.world.addContactMaterial(new CANNON.ContactMaterial(
        pMaterialBall, pMaterialWall, 0.2, 0.1
      ));

      pWorld.world.addContactMaterial(new CANNON.ContactMaterial(
        pMaterialWall, pMaterialFloor, 0.2, 0.1
      ));

			pWorld.world.addContactMaterial(new CANNON.ContactMaterial(
				pMaterialBall, pMaterialObstacle, 10, 0
			));

			pWorld.world.addContactMaterial(new CANNON.ContactMaterial(
				pMaterialObstacle, pMaterialFloor, 0.01, 0.1
			));

			pWorld.world.addContactMaterial(new CANNON.ContactMaterial(
				pMaterialObstacle, pMaterialWall, 0, 0
			));

			pWorld.world.addContactMaterial(new CANNON.ContactMaterial(
				pMaterialObstacle, pMaterialObstacle, 0, 0
			));

      var floor = makeFloor(-6, -4, 6, 4);
      scene.add(floor);
			let floorShape = new CANNON.Box(new CANNON.Vec3(
				floor.geometry.parameters.width,
				floor.geometry.parameters.height/2,
				floor.geometry.parameters.depth/2
			));
			var floorBody = new THREEx.CannonBody({
				shape: floorShape,
        mesh: floor,
        mass: 0,
        material: pMaterialFloor
      });
      floorBody.addTo(pWorld);

      var ball = makeBall(0.2);
      scene.add(ball);
			var ballBody = new THREEx.CannonBody({
				mesh: ball,
				mass: 20,
				material: pMaterialBall
			});
			ballBody.addTo(pWorld);
			ballBody.body.linearDamping = 0.8;
			ballBody.body.angularDamping = 0.9;

      var leftWall = makeWall(-6, -4, -5.8, 4);
      scene.add(leftWall);
			var leftWallBody = new THREEx.CannonBody({
        mesh: leftWall,
        mass: 0,
        material: pMaterialWall
      });
      leftWallBody.addTo(pWorld);

      var rightWall = makeWall(5.8, -4, 6, 4);
      scene.add(rightWall);
			var rightWallBody = new THREEx.CannonBody({
				mesh: rightWall,
				mass: 0,
				material: pMaterialWall
			});
			rightWallBody.addTo(pWorld);

      var bottomWall = makeWall(-6, 3.8, 6, 4);
      scene.add(bottomWall);
			var bottomWallBody = new THREEx.CannonBody({
        mesh: bottomWall,
        mass: 0,
        material: pMaterialWall
      });
      bottomWallBody.addTo(pWorld);

      var topWall = makeWall(-6, -4.2, 6, -4);
      scene.add(topWall);
			var topWallBody = new THREEx.CannonBody({
        mesh: topWall,
        mass: 0,
        material: pMaterialWall
      });
      topWallBody.addTo(pWorld);

			var midLeftWall = makeWall(-3.1, -1.8, -2.9, 3.8);
			scene.add(midLeftWall);
			var midLeftWallBody = new THREEx.CannonBody({
        mesh: midLeftWall,
        mass: 0,
        material: pMaterialWall
      });
      midLeftWallBody.addTo(pWorld);

			var midWall = makeWall(-0.1, -3.8, 0.1, 1.8);
			scene.add(midWall);
			var midWallBody = new THREEx.CannonBody({
				mesh: midWall,
				mass: 0,
				material: pMaterialWall
			});
			midWallBody.addTo(pWorld);

			var midRightWall = makeWall(2.9, -1.8, 3.1, 3.8);
			scene.add(midRightWall);
			var midRightWallBody = new THREEx.CannonBody({
        mesh: midRightWall,
        mass: 0,
        material: pMaterialWall
      });
      midRightWallBody.addTo(pWorld);

			var sphericalObstacle1 = makeSphericalObstacle(0.4, -2.7, -1.6);
			scene.add(sphericalObstacle1);
			var sphericalObstacle1Body = new THREEx.CannonBody({
				mesh: sphericalObstacle1,
				mass: 300,
				material: pMaterialObstacle
			});
			sphericalObstacle1Body.addTo(pWorld);
			sphericalObstacle1Body.body.linearDamping = 0.8;
      sphericalObstacle1Body.body.angularDamping = 0.9;

			var sphericalObstacle2 = makeSphericalObstacle(0.4, 0, 2.7);
			scene.add(sphericalObstacle2);
			var sphericalObstacle2Body = new THREEx.CannonBody({
				mesh: sphericalObstacle2,
				mass: 300,
				material: pMaterialObstacle
			});
			sphericalObstacle2Body.addTo(pWorld);
			sphericalObstacle2Body.body.linearDamping = 0.8;
      sphericalObstacle2Body.body.angularDamping = 0.9;

			var sphericalObstacle3 = makeSphericalObstacle(0.4, 2.7, -1.6);
			scene.add(sphericalObstacle3);
			var sphericalObstacle3Body = new THREEx.CannonBody({
				mesh: sphericalObstacle3,
				mass: 300,
				material: pMaterialObstacle
			});
			sphericalObstacle3Body.addTo(pWorld);
			sphericalObstacle3Body.body.linearDamping = 0.8;
      sphericalObstacle3Body.body.angularDamping = 0.9;

			var sphericalObstacles = [ sphericalObstacle1Body, sphericalObstacle2Body, sphericalObstacle3Body ];

			var homeBall = makeHomeBall(0.4, 4.3, 3.4);
			scene.add(homeBall);
			var homeBallBody = new THREEx.CannonBody({
				mesh: homeBall,
				mass: 300,
				material: pMaterialObstacle
			});
			homeBallBody.addTo(pWorld);
			homeBallBody.body.linearDamping = 0.8;
      homeBallBody.body.angularDamping = 0.9;

			var rotatingCubePos = [];

			var rotatingCube1 = makeRotatingCube(-4.8, -0.1, -3.8, 0.1);
			scene.add(rotatingCube1);
			let rotatingCube1Shape = new CANNON.Box(new CANNON.Vec3(
				rotatingCube1.geometry.parameters.width,
				rotatingCube1.geometry.parameters.height/2,
				rotatingCube1.geometry.parameters.depth/2
			));
			var rotatingCube1Body = new THREEx.CannonBody({
				shape: rotatingCube1Shape,
				mesh: rotatingCube1,
				mass: 200,
				material: pMaterialObstacle
			});
			rotatingCube1Body.addTo(pWorld);
			rotatingCube1Body.body.linearDamping = 0.8;
			rotatingCube1Body.body.angularDamping = 0.9;

			rotatingCubePos.push({ x: -4.3, z: 0});

			var rotatingCubes = [ rotatingCube1Body ];

      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );
      window.addEventListener( 'resize', onWindowResize, false );

      render();
      // animate();

      var lastTimeMsec = null;
      let animate = function (nowMsec) {
				requestAnimationFrame(animate);  // async
        lastTimeMsec	= lastTimeMsec || (nowMsec-1000/60);
        var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec);
        lastTimeMsec	= nowMsec;
				floorBody.update(deltaMsec/1000, nowMsec/1000);
				rotatingCubes.forEach((body, idx) => {
					body.body.position.x = rotatingCubePos[idx].x;
					body.body.position.z = rotatingCubePos[idx].z;
					body.body.angularVelocity.set(0, 5, 0);
					body.update(deltaMsec/1000, nowMsec/1000);
				});
				sphericalObstacles.forEach((body) => {
					body.update(deltaMsec/1000, nowMsec/1000);
				});
        moveBall(keyboard, ballBody, nowMsec, deltaMsec);
        renderer.render(scene, camera);
      }
      requestAnimationFrame(animate);

      function render() {
        renderer.render( scene, camera );
      }

      function onWindowResize() {
		    camera.aspect = window.innerWidth / window.innerHeight;
		    camera.updateProjectionMatrix();
		    renderer.setSize( window.innerWidth, window.innerHeight );
		    render();
			}

    </script>
  </body>
</html>
