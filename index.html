<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Threeter</title>
    <style media="screen">
      canvas { width: 100%; height: 100% }
      body { margin: 0 auto; }
    </style>
    <script src='./vendor/three.js'></script>
    <script src='./lib/game.js'></script>
    <script src="./vendor/cannon.js"></script>
    <script src="./vendor/threex.cannonbody.js"></script>
    <script src="./vendor/threex.cannonworld.js"></script>
    <script src="./vendor/threex.keyboardstate.js"></script>
  </head>
  <body>
    <h1>Threeter</h1>
    <script type="text/javascript">

      var keyboard = new THREEx.KeyboardState(document.body);
      keyboard.domElement.setAttribute("tabIndex", "0");
	    keyboard.domElement.focus();

      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.x	= 0;
    	camera.position.y	= 6;
    	camera.position.z	= 5;
    	camera.lookAt( scene.position );
      var renderer = new THREE.WebGLRenderer();

      var pWorld = new THREEx.CannonWorld();
      pWorld.start();

      var light = new THREE.AmbientLight( 0xffffff );
      scene.add(light);

      var floor = makeFloor(-6, -4, 6, 4);
      scene.add(floor);

      var ball = makeBall(0.2);
      scene.add(ball);

      var leftWall = makeWall(-6, -4, -5.8, 4);
      scene.add(leftWall);

      var rightWall = makeWall(5.8, -4, 6, 4);
      scene.add(rightWall);

      var bottomWall = makeWall(-6, 3.8, 6, 4);
      scene.add(bottomWall);

      var topWall = makeWall(-6, -4.2, 6, -4);
      scene.add(topWall);

      var pMaterialFloor = new CANNON.Material('pMaterialFloor');
      var pMaterialBall = new CANNON.Material('pMaterialBall');
      var pMaterialWall = new CANNON.Material('pMaterialWall');

      pWorld.world.addContactMaterial(new CANNON.ContactMaterial(
        pMaterialBall, pMaterialFloor, 0.1, 0.2
      ));

      pWorld.world.addContactMaterial(new CANNON.ContactMaterial(
        pMaterialBall, pMaterialWall, 0.1, 0.2
      ));

      pWorld.world.addContactMaterial(new CANNON.ContactMaterial(
        pMaterialWall, pMaterialFloor, 0.1, 0.2
      ));

      var floorBody = new THREEx.CannonBody({
        mesh: floor,
        mass: 0,
        material: pMaterialFloor
      });
      floorBody.addTo(pWorld);

      var ballBody = new THREEx.CannonBody({
        mesh: ball,
        mass: 20,
        material: pMaterialBall
      });
      ballBody.addTo(pWorld);
      ballBody.body.linearDamping = 0.8;
      ballBody.body.angularDamping = 0.9;

      var leftWallBody = new THREEx.CannonBody({
        mesh: leftWall,
        mass: 0,
        material: pMaterialWall
      });
      leftWallBody.addTo(pWorld);

      var rightWallBody = new THREEx.CannonBody({
        mesh: rightWall,
        mass: 0,
        material: pMaterialWall
      });
      rightWallBody.addTo(pWorld);

      var bottomWallBody = new THREEx.CannonBody({
        mesh: bottomWall,
        mass: 0,
        material: pMaterialWall
      });
      bottomWallBody.addTo(pWorld);

      var topWallBody = new THREEx.CannonBody({
        mesh: topWall,
        mass: 0,
        material: pMaterialWall
      });
      topWallBody.addTo(pWorld);

      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );
      window.addEventListener( 'resize', onWindowResize, false );

      render();
      // animate();

      var lastTimeMsec = null;
      let animate = function (nowMsec) {
				requestAnimationFrame(animate);  // async
        lastTimeMsec	= lastTimeMsec || (nowMsec-1000/60);
        var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec);
        lastTimeMsec	= nowMsec;
        moveBall(keyboard, ballBody, nowMsec, deltaMsec);
				// updateCameraPosition(camera, ballBody);
        renderer.render(scene, camera);
      }
      requestAnimationFrame(animate);

      function render() {
        renderer.render( scene, camera );
      }

      function onWindowResize() {
		    camera.aspect = window.innerWidth / window.innerHeight;
		    camera.updateProjectionMatrix();
		    renderer.setSize( window.innerWidth, window.innerHeight );
		    render();
			}

    </script>
  </body>
</html>
